Exercise 1:
1. 
2. 34, 9th fabonacci number
3. 0x10000010

Exercise 2:
1. The register representing the variable k: t0
2. The register representing the variable sum: s0
3. The registers acting as pointers to the source and dest arrays: s1, s2
4. The assembly code for the loop found in the C code: label loop
5. How the pointers are manipulated in the assembly code:
counter k stored in t0 is multiplied by 4 and result is stored in t2 then t2 is used as pointer to the next element in the source array, similarly for dest.

Exercise 4:
1. What caused the errors in simple_fn, naive_pow, and inc_arr that were reported by the Venus CC checker?
simple_fn: used t0 from the caller without setting it
naive_pow: used s0 register without preserving its content for the caller
inc_arr: used s0 and s1 without preserving their content for the caller, and called helper_fn without storing t0 before the call

2. In RISC-V, we call functions by jumping to them and storing the return address in the ra register. Does calling convention apply to the jumps to the naive_pow_loop or naive_pow_end labels?
no, because they act as loop labels not functions

3. Why do we need to store ra in the prologue for inc_arr, but not in any other function?
because inc_arr calls another function i.e. helper_fn which disrupts inc_arr ra register

4. Why wasn’t the calling convention error in helper_fn reported by the CC checker? (Hint: it’s mentioned above in the exercise instructions.)
because it is a nested call